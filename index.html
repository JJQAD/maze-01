<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Tilt Maze Â· JJQAD</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Tilt Maze" />
  <style>
    :root{color-scheme:light dark}
    html,body{height:100%;margin:0}
    body{display:flex;align-items:center;justify-content:center;background:#f5f5f7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #wrap{position:relative;width:100vw;height:100vh;display:flex;align-items:center;justify-content:center}
    canvas{display:block;border-radius:24px;box-shadow:0 10px 30px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.15)}

    /* Splash / permission overlay */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:20;opacity:1;transition:opacity .45s ease}
    .overlay.fade-out{opacity:0;pointer-events:none}
    .overlay.hidden{display:none}
    .card{backdrop-filter:blur(8px);background:rgba(255,255,255,.9);border:1px solid rgba(0,0,0,.08);border-radius:16px;padding:22px 24px;max-width:84%;text-align:center;box-shadow:0 6px 20px rgba(0,0,0,.12)}
    .title{font-weight:800;font-size:1.6rem;letter-spacing:.2px;margin-bottom:6px}
    .sub{opacity:.75;margin-bottom:14px}
    .btn{appearance:none;border:0;border-radius:12px;padding:12px 16px;font-weight:700;cursor:pointer;background:#111;color:#fff}
    .hint{font-size:.92rem;opacity:.8;margin-top:12px}
    .tiny{font-size:.8rem;opacity:.68;margin-top:6px}

    /* Portrait reminder when device is landscape */
    #rotate{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);color:#fff;z-index:30;text-align:center;padding:20px}
    #rotate.show{display:flex}

    .debug{position:absolute;left:10px;top:10px;z-index:10;background:rgba(0,0,0,.55);color:#fff;padding:6px 8px;border-radius:8px;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:12px}

    @media (prefers-color-scheme:dark){
      body{background:#0f1114}
      .card{background:rgba(20,22,26,.86);color:#eaeef2;border-color:rgba(255,255,255,.1)}
      .btn{background:#e11d48}
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <div id="wrap">
    <div id="splash" class="overlay">
      <div class="card">
        <div class="title">Tilt Maze</div>
        <div class="sub">by JJQAD</div>
        <button class="btn" id="beginBtn">Tap to Begin</button>
        <div class="hint">Tilt your phone to move the ball and solve the maze.</div>
        <div class="tiny">You'll be asked to allow motion/orientation sensors.</div>
      </div>
    </div>
    <div id="rotate"><div>Rotate to portrait</div></div>
    <div id="dbg" class="debug" hidden>debug</div>
  </div>

<script>
// =================== Responsive sizing ===================
let SIZE = 400; // canvas size = viewport width (square)
function computeSize(){
  const w = Math.min(window.innerWidth, 1024);
  SIZE = Math.floor(w);
}

// =================== Game config (will scale with level) ===================
let cx, cy;            // canvas center
let cellSize;          // maze cell size (px)
let PATH_W;            // visual path (channel) width
let BALL_R;            // ball radius
let GOAL_R;            // goal dot radius (50% of ball)
let level = 1;         // increases after each solve

// physics
const GRAVITY = 0.32;
const FRICTION = 0.992;
const BOUNCE = 0.25;
let pos = {x:0,y:0}, vel = {x:0,y:0}, acc = {x:0,y:0};
let usingOrientation = false, havePermission = false;
let lastGamma = 0, lastBeta = 0;

// maze
let gridW, gridH;        // cells across/down
let mazeEdges = [];      // list of corridor segments (for drawing)
let startCell, endCell;  // {i,j}
let startPos, endPos;    // pixel positions
let solved = false;

// offscreen collision mask
let maskCanvas, maskCtx, maskData;

// =================== Utilities ===================
function fadeOut(el){ el.classList.add('fade-out'); el.addEventListener('transitionend', ()=>el.classList.add('hidden'), {once:true}); }
function isIOS(){ return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints>1); }

// =================== Maze generation (Randomized Prim) ===================
function generateMaze(cols, rows){
  // Prim on cell graph with 4-neighborhood
  const N=rows, M=cols;
  const inMST = Array.from({length:N},()=>Array(M).fill(false));
  const edges=[]; // frontier edges: [i,j,dir]
  const dirs=[[1,0,'R'],[-1,0,'L'],[0,1,'D'],[0,-1,'U']];
  function pushEdges(i,j){
    for(const [dx,dy,tag] of dirs){
      const ni=i+dy, nj=j+dx; // careful: i=row(y), j=col(x)
      if(ni>=0&&ni<N&&nj>=0&&nj<M&&!inMST[ni][nj]) edges.push([i,j,ni,nj]);
    }
  }
  // seed
  const si = Math.floor(Math.random()*N), sj = Math.floor(Math.random()*M);
  inMST[si][sj]=true; pushEdges(si,sj);
  const passages = new Set(); // key as "i,j -> ni,nj"

  while(edges.length){
    const k = Math.floor(Math.random()*edges.length);
    const [i,j,ni,nj]=edges.splice(k,1)[0];
    if(inMST[ni][nj] && inMST[i][j]) continue;
    const ai = inMST[i][j]? i:ni, aj=inMST[i][j]? j:nj;
    const bi = inMST[i][j]? ni:i, bj=inMST[i][j]? nj:j;
    inMST[bi][bj]=true; pushEdges(bi,bj);
    passages.add(`${ai},${aj}-${bi},${bj}`);
    passages.add(`${bi},${bj}-${ai},${aj}`);
  }

  // compute farthest endpoints via BFS distances
  function cellToIdx(i,j){ return i*M + j; }
  const adj = Array.from({length:N*M},()=>[]);
  for(let i=0;i<N;i++)for(let j=0;j<M;j++){
    const id=cellToIdx(i,j);
    for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const ni=i+dy,nj=j+dx; if(ni<0||nj<0||ni>=N||nj>=M) continue;
      if(passages.has(`${i},${j}-${ni},${nj}`)) adj[id].push(cellToIdx(ni,nj));
    }
  }
  function bfs(start){
    const dist=Array(N*M).fill(Infinity); dist[start]=0; const q=[start];
    while(q.length){
      const v=q.shift();
      for(const w of adj[v]) if(dist[w]===Infinity){ dist[w]=dist[v]+1; q.push(w);} }
    return dist;
  }
  const s0 = 0; // arbitrary start
  const d0 = bfs(s0);
  let a=0; for(let k=0;k<d0.length;k++) if(d0[k]>d0[a]) a=k;
  const d1=bfs(a); let b=0; for(let k=0;k<d1.length;k++) if(d1[k]>d1[b]) b=k;
  const ai=Math.floor(a/M), aj=a%M, bi=Math.floor(b/M), bj=b%M;

  // store edges as pixel segments later
  return {passages, start:{i:ai,j:aj}, end:{i:bi,j:bj}, cols:M, rows:N};
}

function buildMazeGeometry(){
  // choose grid based on level/size
  const base = Math.max(8, Math.floor(SIZE/Math.max(44, 54 - level*3))); // heuristic
  gridW = base; gridH = base; // square grid
  cellSize = Math.floor(SIZE / (gridW + 2)); // padding 1 cell around
  PATH_W = Math.floor(cellSize * 0.56);
  BALL_R = Math.floor(PATH_W * 0.45); // keep some clearance
  GOAL_R = Math.floor(BALL_R * 0.5);
  cx = SIZE/2; cy = SIZE/2;

  const m = generateMaze(gridW, gridH);
  startCell = m.start; endCell = m.end;

  // convert passages to line segments in pixel space (centerlines)
  mazeEdges = [];
  function cellCenter(i,j){
    const x = cellSize*(j+1) + cellSize/2;
    const y = cellSize*(i+1) + cellSize/2;
    return {x,y};
  }
  for(let i=0;i<gridH;i++) for(let j=0;j<gridW;j++){
    const id = `${i},${j}`;
    for(const [dx,dy] of [[1,0],[0,1]]){ // only right & down to avoid dupes
      const ni=i+dy,nj=j+dx; if(ni>=gridH||nj>=gridW) continue;
      const keyAB = `${i},${j}-${ni},${nj}`;
      if(m.passages.has(keyAB)){
        const A = cellCenter(i,j), B = cellCenter(ni,nj);
        mazeEdges.push([A,B]);
      }
    }
  }
  startPos = cellCenter(startCell.i, startCell.j);
  endPos   = cellCenter(endCell.i,   endCell.j);
  pos = {x:startPos.x, y:startPos.y}; vel={x:0,y:0};

  // build collision mask
  buildCollisionMask();
}

function buildCollisionMask(){
  maskCanvas = document.createElement('canvas');
  maskCanvas.width = SIZE; maskCanvas.height = SIZE;
  maskCtx = maskCanvas.getContext('2d');
  maskCtx.clearRect(0,0,SIZE,SIZE);
  // draw paths (grey on main, white on mask over black background)
  maskCtx.fillStyle='#000'; maskCtx.fillRect(0,0,SIZE,SIZE);
  maskCtx.lineCap='round'; maskCtx.lineJoin='round';
  maskCtx.lineWidth = PATH_W;
  maskCtx.strokeStyle='#fff';
  // draw outer padding cross-connections through passages
  for(const [A,B] of mazeEdges){
    maskCtx.beginPath(); maskCtx.moveTo(A.x, A.y); maskCtx.lineTo(B.x, B.y); maskCtx.stroke();
  }
  // Start/End centers are already on paths
  maskData = maskCtx.getImageData(0,0,SIZE,SIZE).data;
}

function pointInsidePath(x,y){
  // sample mask (white = path)
  const ix = Math.max(0, Math.min(SIZE-1, Math.round(x)));
  const iy = Math.max(0, Math.min(SIZE-1, Math.round(y)));
  const idx = (iy*SIZE + ix)*4 + 0; // read red
  return maskData[idx] > 127; // on path if bright
}

function ballCanBeAt(nx,ny){
  // sample 8 points around the ball edge; all must be on the path
  const s = Math.max(6, Math.floor(BALL_R/3));
  for(let a=0;a<8;a++){
    const th = (Math.PI*2*a)/8;
    const px = nx + Math.cos(th)*(BALL_R-1);
    const py = ny + Math.sin(th)*(BALL_R-1);
    if(!pointInsidePath(px,py)) return false;
  }
  // also sample center
  return pointInsidePath(nx,ny);
}

// =================== Rendering ===================
function drawPaths(ctx){
  ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,SIZE,SIZE);
  ctx.lineCap='round'; ctx.lineJoin='round'; ctx.lineWidth=PATH_W; ctx.strokeStyle='#d7d7db';
  for(const [A,B] of mazeEdges){ ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke(); }
}
function drawGoal(ctx){
  ctx.fillStyle='#f59e0b'; // orange
  ctx.beginPath(); ctx.arc(endPos.x, endPos.y, GOAL_R, 0, Math.PI*2); ctx.fill();
}
function drawBall(ctx){
  ctx.fillStyle='#e11d48';
  ctx.beginPath(); ctx.arc(pos.x, pos.y, BALL_R, 0, Math.PI*2); ctx.fill();
}

// =================== p5 Sketch ===================
function setup(){
  computeSize();
  const c = createCanvas(SIZE, SIZE); c.parent('wrap');
  pixelDensity(Math.min(2, window.devicePixelRatio||1));
  initSplash();
  setupOrientationGuard();
  window.addEventListener('resize', onResize);
}

function onResize(){
  const old = SIZE; computeSize(); resizeCanvas(SIZE, SIZE);
  if (maskCanvas){ buildMazeGeometry(); }
}

function draw(){
  const ctx = this.drawingContext;
  if(!maskCanvas){ // waiting on start
    // draw simple cross placeholder
    ctx.fillStyle='#fff'; ctx.fillRect(0,0,SIZE,SIZE);
    return;
  }
  drawPaths(ctx);
  drawGoal(ctx);

  // physics
  let ax=0, ay=0; if(usingOrientation){ ax+=acc.x; ay+=acc.y; }
  vel.x = (vel.x + ax) * FRICTION; vel.y = (vel.y + ay) * FRICTION;
  const nx = pos.x + vel.x, ny = pos.y + vel.y;
  if(ballCanBeAt(nx,ny)){
    pos.x = nx; pos.y = ny;
  } else {
    // simple bounce: invert smallest offending component
    const tryX = ballCanBeAt(pos.x + vel.x, pos.y);
    const tryY = ballCanBeAt(pos.x, pos.y + vel.y);
    if(tryX) pos.x += vel.x; else vel.x *= -BOUNCE;
    if(tryY) pos.y += vel.y; else vel.y *= -BOUNCE;
  }

  drawBall(ctx);

  // check goal
  const d = Math.hypot(pos.x-endPos.x, pos.y-endPos.y);
  if(!solved && d < GOAL_R*0.9){ solved = true; nextLevel(); }
}

function nextLevel(){
  level++;
  buildMazeGeometry();
  solved=false;
}

// =================== Device Orientation ===================
function handleOrientation(e){
  const g = e.gamma ?? 0; const b = e.beta ?? 0; lastGamma=g; lastBeta=b;
  acc.x = GRAVITY * Math.sin(g*Math.PI/180);
  acc.y = GRAVITY * Math.sin(b*Math.PI/180);
}
async function askPermission(){
  try{
    let ok = true;
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
      const p1 = await DeviceOrientationEvent.requestPermission(); ok = ok && (p1==='granted');
    }
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      const p2 = await DeviceMotionEvent.requestPermission(); ok = ok && (p2==='granted');
    }
    if (ok){ havePermission=true; startOrientation(); }
  }catch(err){ console.warn('Permission error', err); }
}
function startOrientation(){ window.addEventListener('deviceorientation', handleOrientation, true); usingOrientation = true; }

// =================== Splash / Start ===================
function initSplash(){
  const splash = document.getElementById('splash');
  const beginBtn = document.getElementById('beginBtn');
  const needsPerm = isIOS() && (typeof DeviceOrientationEvent!== 'undefined') && (typeof DeviceOrientationEvent.requestPermission==='function');
  beginBtn.addEventListener('click', async ()=>{
    if(needsPerm) await askPermission(); else startOrientation();
    buildMazeGeometry();
    fadeOut(splash);
  }, {once:true});
}

// =================== Portrait guard ===================
let mql;
function setupOrientationGuard(){
  mql = window.matchMedia('(orientation: landscape)');
  mql.addEventListener('change', updateOrientationGuard); updateOrientationGuard();
}
function updateOrientationGuard(){
  const rot = document.getElementById('rotate');
  if (window.matchMedia('(orientation: landscape)').matches){ rot.classList.add('show'); }
  else { rot.classList.remove('show'); }
}
</script>
</body>
</html>
