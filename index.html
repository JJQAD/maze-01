<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Tilt Maze · JJQAD</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Tilt Maze" />
  <style>
    :root{color-scheme:light dark}
    html,body{height:100dvh;margin:0}
    body{display:flex;align-items:center;justify-content:center;background:#f5f5f7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #wrap{position:relative;width:100vw;height:100dvh;display:flex;align-items:center;justify-content:center}
    canvas{display:block;border-radius:24px;box-shadow:0 10px 30px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.15)}

    /* Overlays */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:20;opacity:1;transition:opacity .45s ease}
    .overlay.fade-out{opacity:0;pointer-events:none}
    .overlay.hidden{display:none}
    .card{backdrop-filter:blur(8px);background:rgba(255,255,255,.9);border:1px solid rgba(0,0,0,.08);border-radius:16px;padding:22px 24px;max-width:88%;text-align:center;box-shadow:0 6px 20px rgba(0,0,0,.12)}
    .title{font-weight:800;font-size:1.6rem;letter-spacing:.2px;margin-bottom:6px}
    .sub{opacity:.75;margin-bottom:14px}
    .btn{appearance:none;border:0;border-radius:12px;padding:12px 16px;font-weight:700;cursor:pointer;background:#111;color:#fff}
    .hint{font-size:.92rem;opacity:.8;margin-top:12px}
    .tiny{font-size:.8rem;opacity:.68;margin-top:6px}

    #rotate{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);color:#fff;z-index:30;text-align:center;padding:20px}
    #rotate.show{display:flex}

    .debug{position:absolute;left:10px;top:10px;z-index:10;background:rgba(0,0,0,.55);color:#fff;padding:6px 8px;border-radius:8px;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:12px}
    .version-tag{position:absolute;right:10px;bottom:8px;z-index:40;font-size:11px;opacity:.6;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}

    @media (prefers-color-scheme:dark){
      body{background:#0f1114}
      .card{background:rgba(20,22,26,.86);color:#eaeef2;border-color:rgba(255,255,255,.1)}
      .btn{background:#e11d48}
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <div id="wrap">
    <div id="splash" class="overlay">
      <div class="card">
        <div class="title">Tilt Maze</div>
        <div class="sub">by JJQAD</div>
        <button class="btn" id="beginBtn">Tap to Begin</button>
        <div class="hint">Tilt your phone to move the ball and solve the maze.</div>
        <div class="tiny">You'll be asked to allow motion/orientation sensors.</div>
        <div class="tiny" id="splashVersion"></div>
      </div>
    </div>

    <div id="congrats" class="overlay hidden">
      <div class="card">
        <div class="title">Congratulations!</div>
        <div class="sub">Want another?</div>
        <div>
          <button class="btn" id="againEasy">Easy</button>
          <button class="btn" id="againMed">Medium</button>
          <button class="btn" id="againHard">Hard</button>
        </div>
      </div>
    </div>
        <div class="sub">Want another?</div>
        <button class="btn" id="againBtn">Yes</button>
      </div>
    </div>

    <div id="rotate"><div>Rotate to portrait</div></div>
    <div id="dbg" class="debug" hidden>debug</div>
    <div id="verTag" class="version-tag"></div>
  </div>

<script>
const VERSION = 'v2025-10-20a';

// =================== Responsive sizing (full-screen) ===================
let CAN_W = 400, CAN_H = 700; // full screen canvas
function computeSize(){ CAN_W = window.innerWidth; CAN_H = window.innerHeight; }

// =================== Game config (scales with level) ===================
let cellSize;          // maze cell size (px)
let PATH_W;            // visual path width
let BALL_R;            // ball radius
let GOAL_R;            // goal dot radius (50% of ball)
let level = 1;
let difficulty = 'medium'; // 'easy' | 'medium' | 'hard'
$1

// physics
const GRAVITY = 0.32;
const FRICTION = 0.992;
const BOUNCE = 0.25;
let pos = {x:0,y:0}, vel = {x:0,y:0}, acc = {x:0,y:0};
let usingOrientation = false, havePermission = false;
let lastGamma = 0, lastBeta = 0;

// maze
let gridW, gridH;        // cells across/down
let mazeEdges = [];      // list of corridor centerline segments
let startCell, endCell;  // {i,j}
let startPos, endPos;    // pixel positions
let solved = false;

// collision mask for BALL CENTER (eroded by BALL_R)
let centerMask;

// =================== Utilities ===================
function fadeOut(el){ el.classList.add('fade-out'); el.addEventListener('transitionend', ()=>el.classList.add('hidden'), {once:true}); }
function isIOS(){ return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints>1); }

// =================== Maze generation (Wilson's Algorithm) ===================
function generateMaze(cols, rows){
  const H=rows, W=cols;
  const inTree = Array.from({length:H},()=>Array(W).fill(false));
  const dirs = [[1,0],[ -1,0],[0,1],[0,-1]];
  const neighbors = (i,j)=>{ const out=[]; for(const [dx,dy] of dirs){ const ni=i+dy, nj=j+dx; if(ni>=0&&nj>=0&&ni<H&&nj<W) out.push([ni,nj]); } return out; };
  // seed
  const si = Math.floor(Math.random()*H), sj=Math.floor(Math.random()*W); inTree[si][sj]=true;
  const parent = Array.from({length:H},()=>Array(W).fill(null));
  const total = H*W; let added = 1;
  while(added < total){
    let ui, uj; do { ui=Math.floor(Math.random()*H); uj=Math.floor(Math.random()*W);} while(inTree[ui][uj]);
    const path=[]; const index=new Map();
    let ci=ui, cj=uj; path.push([ci,cj]); index.set(ci+','+cj,0);
    while(!inTree[ci][cj]){
      const opts = neighbors(ci,cj);
      const [ni,nj] = opts[Math.floor(Math.random()*opts.length)];
      const key = ni+','+nj;
      if(index.has(key)){
        const cut = index.get(key);
        path.length = cut+1; // loop erase
      } else {
        path.push([ni,nj]); index.set(key, path.length-1);
      }
      ci=ni; cj=nj;
    }
    for(let k=0;k<path.length-1;k++){
      const [a1,b1]=path[k], [a2,b2]=path[k+1];
      if(!inTree[a1][b1]){ inTree[a1][b1]=true; added++; parent[a1][b1]=a2+','+b2; }
      if(!inTree[a2][b2]){ inTree[a2][b2]=true; added++; parent[a2][b2]=a1+','+b1; }
    }
  }
  const passages = new Set();
  for(let i=0;i<H;i++) for(let j=0;j<W;j++){
    const p = parent[i][j]; if(!p) continue; const [pi,pj]=p.split(',').map(Number);
    const a=`${i},${j}`, b=`${pi},${pj}`; passages.add(a+"-"+b); passages.add(b+"-"+a);
  }
  function cellToIdx(i,j){ return i*W + j; }
  const adj = Array.from({length:H*W},()=>[]);
  for(let i=0;i<H;i++)for(let j=0;j<W;j++){
    const id=cellToIdx(i,j);
    for(const [dx,dy] of dirs){ const ni=i+dy,nj=j+dx; if(ni<0||nj<0||ni>=H||nj>=W) continue; if(passages.has(`${i},${j}-${ni},${nj}`)) adj[id].push(cellToIdx(ni,nj)); }
  }
  function bfs(start){ const dist=Array(H*W).fill(Infinity); dist[start]=0; const q=[start]; while(q.length){ const v=q.shift(); for(const w of adj[v]) if(dist[w]===Infinity){ dist[w]=dist[v]+1; q.push(w);} } return dist; }
  const s0=0, d0=bfs(s0); let a=0; for(let k=0;k<d0.length;k++) if(d0[k]>d0[a]) a=k; const d1=bfs(a); let b=0; for(let k=0;k<d1.length;k++) if(d1[k]>d1[b]) b=k;
  const ai=Math.floor(a/W), aj=a%W, bi=Math.floor(b/W), bj=b%W;
  return {passages, start:{i:ai,j:aj}, end:{i:bi,j:bj}, cols:W, rows:H};
}

function buildMazeGeometry(){
  // Difficulty → target cell size (px)
  const target = (difficulty==='easy') ? 54 : (difficulty==='hard' ? 28 : 36);
  cellSize = Math.max(18, target - Math.max(0, level-1));
  gridW = Math.max(8, Math.floor(CAN_W / cellSize) - 2);
  gridH = Math.max(8, Math.floor(CAN_H / cellSize) - 2);
  // Refit to exactly fill with uniform square cells and ~1-cell margin
  cellSize = Math.floor(Math.min(CAN_W / (gridW + 2), CAN_H / (gridH + 2)));
  const offsetX = Math.floor((CAN_W - (gridW+2)*cellSize)/2);
  const offsetY = Math.floor((CAN_H - (gridH+2)*cellSize)/2);

  PATH_W = Math.floor(cellSize * 0.56);
  BALL_R = Math.floor(PATH_W * 0.45);
  GOAL_R = Math.floor(BALL_R * 0.5);

  const m = generateMaze(gridW, gridH);
  startCell = m.start; endCell = m.end;

  mazeEdges = [];
  function cellCenter(i,j){
    const x = cellSize*(j+1) + cellSize/2 + offsetX;
    const y = cellSize*(i+1) + cellSize/2 + offsetY;
    return {x,y};
  }
  for(let i=0;i<gridH;i++) for(let j=0;j<gridW;j++){
    for(const [dx,dy] of [[1,0],[0,1]]){ // right & down only
      const ni=i+dy,nj=j+dx; if(ni>=gridH||nj>=gridW) continue;
      if(m.passages.has(`${i},${j}-${ni},${nj}`)){
        const A = cellCenter(i,j), B = cellCenter(ni,nj);
        mazeEdges.push([A,B]);
      }
    }
  }
  startPos = cellCenter(startCell.i, startCell.j);
  endPos   = cellCenter(endCell.i,   endCell.j);
  pos = {x:startPos.x, y:startPos.y}; vel={x:0,y:0};

  buildCollisionMask();
}

function buildCollisionMask(){
  // Eroded mask for BALL CENTER (no edge bleed)
  const cCanvas = document.createElement('canvas');
  cCanvas.width = CAN_W; cCanvas.height = CAN_H;
  const cctx = cCanvas.getContext('2d');
  cctx.clearRect(0,0,CAN_W,CAN_H);
  cctx.fillStyle='#000'; cctx.fillRect(0,0,CAN_W,CAN_H);
  cctx.lineCap='round'; cctx.lineJoin='round';
  const eroded = Math.max(1, PATH_W - 2*BALL_R + 2);
  cctx.lineWidth = eroded; cctx.strokeStyle='#fff';
  for(const [A,B] of mazeEdges){ cctx.beginPath(); cctx.moveTo(A.x, A.y); cctx.lineTo(B.x, B.y); cctx.stroke(); }
  centerMask = cctx.getImageData(0,0,CAN_W,CAN_H).data;
} 
  centerMask = cctx.getImageData(0,0,CAN_W,CAN_H).data;
}

function pointInsideCenterMask(x,y){
  const ix = Math.max(0, Math.min(CAN_W-1, Math.round(x)));
  const iy = Math.max(0, Math.min(CAN_H-1, Math.round(y)));
  return centerMask[(iy*CAN_W + ix)*4] > 127;
}

// =================== Rendering ===================
function drawPaths(ctx){
  ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,CAN_W,CAN_H);
  ctx.lineCap='round'; ctx.lineJoin='round'; ctx.lineWidth=PATH_W; ctx.strokeStyle='#d7d7db';
  for(const [A,B] of mazeEdges){ ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke(); }
}
function drawGoal(ctx){
  ctx.fillStyle='#f59e0b';
  ctx.beginPath(); ctx.arc(endPos.x, endPos.y, GOAL_R, 0, Math.PI*2); ctx.fill();
}
function drawBall(ctx){
  ctx.fillStyle='#e11d48';
  ctx.beginPath(); ctx.arc(pos.x, pos.y, BALL_R, 0, Math.PI*2); ctx.fill();
}

// =================== p5 Sketch ===================
function setup(){
  computeSize();
  const c = createCanvas(CAN_W, CAN_H); c.parent('wrap');
  pixelDensity(Math.min(2, window.devicePixelRatio||1));
  initSplash();
  setupOrientationGuard();
  window.addEventListener('resize', onResize);
  document.getElementById('splashVersion').textContent = VERSION;
  document.getElementById('verTag').textContent = VERSION + ' • jjqad.github.io/maze-01/';
}

function onResize(){
  computeSize(); resizeCanvas(CAN_W, CAN_H);
  if (centerMask){ buildMazeGeometry(); }
}

function draw(){
  const ctx = this.drawingContext;
  if(!centerMask){ ctx.fillStyle='#fff'; ctx.fillRect(0,0,CAN_W,CAN_H); return; }
  drawPaths(ctx);
  drawGoal(ctx);

  // physics
  let ax=0, ay=0; if(usingOrientation){ ax+=acc.x; ay+=acc.y; }
  vel.x = (vel.x + ax) * FRICTION; vel.y = (vel.y + ay) * FRICTION;
  let nx = pos.x + vel.x, ny = pos.y + vel.y;
  // strictly keep ball center inside eroded mask
  if(pointInsideCenterMask(nx,ny)){
    pos.x = nx; pos.y = ny;
  } else {
    const tryX = pointInsideCenterMask(pos.x + vel.x, pos.y);
    const tryY = pointInsideCenterMask(pos.x, pos.y + vel.y);
    if(tryX) pos.x += vel.x; else vel.x *= -BOUNCE;
    if(tryY) pos.y += vel.y; else vel.y *= -BOUNCE;
  }

  drawBall(ctx);

  // goal check
  const d = Math.hypot(pos.x-endPos.x, pos.y-endPos.y);
  if(!solved && d < GOAL_R*0.9){ solved = true; showCongrats(); }
}

function nextLevel(){ level++; buildMazeGeometry(); solved=false; }

// =================== Device Orientation ===================
function handleOrientation(e){
  const g = e.gamma ?? 0; const b = e.beta ?? 0; lastGamma=g; lastBeta=b;
  acc.x = GRAVITY * Math.sin(g*Math.PI/180);
  acc.y = GRAVITY * Math.sin(b*Math.PI/180);
}
async function askPermission(){
  try{
    let ok = true;
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
      const p1 = await DeviceOrientationEvent.requestPermission(); ok = ok && (p1==='granted');
    }
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      const p2 = await DeviceMotionEvent.requestPermission(); ok = ok && (p2==='granted');
    }
    if (ok){ havePermission=true; startOrientation(); }
  }catch(err){ console.warn('Permission error', err); }
}
function startOrientation(){ window.addEventListener('deviceorientation', handleOrientation, true); usingOrientation = true; }

// =================== Splash / Start / Congrats ===================
function initSplash(){
  const splash = document.getElementById('splash');
  const beginBtn = document.getElementById('beginBtn');
  const needsPerm = isIOS() && (typeof DeviceOrientationEvent!== 'undefined') && (typeof DeviceOrientationEvent.requestPermission==='function');

  async function startGame(ev){
    try{ ev?.preventDefault?.(); ev?.stopPropagation?.(); }catch(_){}
    try{
      if(needsPerm){
        await askPermission(); // request; may be denied, that's OK
      } else {
        startOrientation();
      }
    }catch(err){ console.warn('begin/permission error', err); }
    // Always proceed to build and fade, even if permission is denied (keyboard still works)
    buildMazeGeometry();
    fadeOut(splash);
  }

  // Bind multiple event types to be safe across iOS Safari versions
  beginBtn.setAttribute('type','button');
  beginBtn.addEventListener('click', startGame, {once:true});
  beginBtn.addEventListener('touchend', startGame, {once:true});
  // Tap anywhere on the overlay also starts
  splash.addEventListener('click', (e)=>{ if(e.target===splash) startGame(e); }, {once:true});
}
, {once:true});
}

function showCongrats(){
  const cg = document.getElementById('congrats');
  cg.classList.remove('hidden');
  cg.classList.remove('fade-out');
  const hook = (d)=>()=>{
    difficulty = d; level = 1;
    cg.classList.add('fade-out');
    cg.addEventListener('transitionend', ()=>{
      cg.classList.add('hidden');
      buildMazeGeometry(); solved=false;
    }, {once:true});
  };
  document.getElementById('againEasy').onclick = hook('easy');
  document.getElementById('againMed').onclick  = hook('medium');
  document.getElementById('againHard').onclick = hook('hard');
}, {once:true});
  };
}

// =================== Portrait guard ===================
let mql;
function setupOrientationGuard(){
  mql = window.matchMedia('(orientation: landscape)');
  mql.addEventListener('change', updateOrientationGuard); updateOrientationGuard();
}
function updateOrientationGuard(){
  const rot = document.getElementById('rotate');
  if (window.matchMedia('(orientation: landscape)').matches){ rot.classList.add('show'); }
  else { rot.classList.remove('show'); }
}
</script>
</body>
</html>
