<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Maze Tilt Test · JJQAD</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Maze Tilt Test" />
  <style>
    :root{color-scheme:light dark}
    html,body{height:100%;margin:0}
    body{display:flex;align-items:center;justify-content:center;background:#f5f5f7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #wrap{position:relative;width:100vw;height:100vh;display:flex;align-items:center;justify-content:center}
    canvas{display:block;border-radius:24px;box-shadow:0 10px 30px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.15)}

    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;opacity:1;transition:opacity .45s ease}
    .overlay.fade-out{opacity:0;pointer-events:none}
    .overlay.hidden{display:none}
    .card{backdrop-filter:blur(8px);background:rgba(255,255,255,.9);border:1px solid rgba(0,0,0,.08);border-radius:16px;padding:18px 20px;max-width:80%;text-align:center;box-shadow:0 6px 20px rgba(0,0,0,.12)}
    .btn{appearance:none;border:0;border-radius:12px;padding:12px 16px;font-weight:600;cursor:pointer;background:#111;color:#fff}
    .muted{font-size:.9rem;opacity:.7;margin-top:8px}
    .debug{position:absolute;left:10px;top:10px;z-index:20;background:rgba(0,0,0,.55);color:#fff;padding:6px 8px;border-radius:8px;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:12px}

    /* Portrait reminder overlay when device is in landscape */
    #rotate{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.5);color:#fff;z-index:30;text-align:center;padding:20px}
    #rotate.show{display:flex}

    @media (prefers-color-scheme:dark){
      body{background:#0f1114}
      .card{background:rgba(20,22,26,.8);color:#eaeef2;border-color:rgba(255,255,255,.1)}
      .btn{background:#e11d48}
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <div id="wrap">
    <div id="overlay" class="overlay">
      <div class="card">
        <div id="ovTitle" style="font-size:1.1rem;font-weight:700;margin-bottom:8px">Enable tilt controls</div>
        <div id="ovText">On iPhone/iPad, Apple requires permission to read motion/orientation sensors.</div>
        <button class="btn" id="ovBtn" style="margin-top:12px">Enable Tilt</button>
        <div class="muted" id="ovHint">(Desktop: use arrow keys to test)</div>
      </div>
    </div>
    <div id="rotate"><div>Rotate to portrait</div></div>
    <div id="dbg" class="debug" hidden>debug</div>
  </div>

<script>
// ========= Responsive sizing =========
let SIZE = 400; // will be set to viewport width
function computeSize(){
  const w = Math.min(window.innerWidth, 1024);
  SIZE = Math.floor(w);
}

// ========= Config (depend on SIZE; recompute on resize) =========
let CHANNEL_W, BALL_R, ARM_LEN, cx, cy, FILLET;
const GRAVITY = 0.33;
const FRICTION = 0.992;
const BOUNCE = 0.2;

function recomputeDerived(){
  CHANNEL_W = Math.max(18, Math.round(SIZE * 0.175));
  BALL_R    = Math.round((CHANNEL_W * 0.98) / 2); // 98% of channel width
  ARM_LEN   = Math.round(SIZE * 0.78);            // length of each trench arm
  FILLET    = Math.max(2, Math.round((CHANNEL_W/2) / 8)); // 1/8 of end radius
  cx = SIZE/2; cy = SIZE/2;
}

// ========= Physics =========
let pos = {x: 0, y: 0};
let vel = {x: 0, y: 0};
let acc = {x: 0, y: 0};
let usingOrientation = false;
let havePermission = false;
let keyAccel = {x:0, y:0};
let lastGamma = 0, lastBeta = 0;
let overlayDismissed = false;

// ========= Geometry helpers =========
function nearestOnSegment(ax,ay,bx,by,px,py){
  const vx = bx-ax, vy = by-ay;
  const wx = px-ax, wy = py-ay;
  const L2 = vx*vx+vy*vy;
  let t = L2 ? (wx*vx+wy*vy)/L2 : 0;
  t = Math.max(0, Math.min(1, t));
  return {x: ax + t*vx, y: ay + t*vy, t};
}
function insideCapsule(p, A, B, rad){
  const n = nearestOnSegment(A.x,A.y,B.x,B.y,p.x,p.y);
  const dx = p.x - n.x, dy = p.y - n.y;
  return (dx*dx + dy*dy) <= rad*rad;
}
function projectToCapsuleBoundary(p, A, B, rad){
  const n = nearestOnSegment(A.x,A.y,B.x,B.y,p.x,p.y);
  const dx = p.x - n.x, dy = p.y - n.y;
  const d = Math.hypot(dx,dy) || 1e-6;
  if (d <= rad) return {point:{x:p.x, y:p.y}, normal:{x:0,y:0}, dist:0};
  const nx = dx/d, ny = dy/d;
  return {point:{x: n.x + nx*rad, y: n.y + ny*rad}, normal:{x:nx, y:ny}, dist: d - rad};
}

function projectToCircle(p, Cx, Cy, rad){
  const dx = p.x - Cx, dy = p.y - Cy;
  const d = Math.hypot(dx,dy) || 1e-6;
  if (d <= rad) return {point:{x:p.x,y:p.y}, normal:{x:0,y:0}, dist:0};
  const nx = dx/d, ny = dy/d;
  return {point:{x: Cx + nx*rad, y: Cy + ny*rad}, normal:{x:nx, y:ny}, dist: d - rad};
}

function unionFilletedCrossClamp(next){
  const half = ARM_LEN/2;
  const hr = CHANNEL_W/2 - BALL_R;
  const horizA = {x: cx - half, y: cy};
  const horizB = {x: cx + half, y: cy};
  const vertA  = {x: cx, y: cy - half};
  const vertB  = {x: cx, y: cy + half};

  const insideH = insideCapsule(next, horizA, horizB, hr);
  const insideV = insideCapsule(next, vertA,  vertB,  hr);
  const insideC = (Math.hypot(next.x-cx, next.y-cy) <= (hr + FILLET));
  if (insideH || insideV || insideC) return {clamped: next, hit:false};

  const ph = projectToCapsuleBoundary(next, horizA, horizB, hr);
  const pv = projectToCapsuleBoundary(next, vertA,  vertB,  hr);
  const pc = projectToCircle(next, cx, cy, hr + FILLET);
  let chosen = ph;
  if (pv.dist < chosen.dist) chosen = pv;
  if (pc.dist < chosen.dist) chosen = pc;

  const nx = chosen.normal.x, ny = chosen.normal.y;
  const dot = vel.x*nx + vel.y*ny;
  if (dot > 0){
    vel.x -= (1+BOUNCE) * dot * nx;
    vel.y -= (1+BOUNCE) * dot * ny;
  }
  return {clamped: chosen.point, hit:true};
}

// ========= Rendering (flat, with inner fillets) =========
function drawPlusFlat(ctx){
  // Background
  ctx.clearRect(0,0,SIZE,SIZE);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,SIZE,SIZE);

  // Base cross: equal arms with rounded ends
  ctx.save();
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.lineWidth = CHANNEL_W;
  ctx.strokeStyle = '#d7d7db';

  // horizontal arm
  ctx.beginPath();
  ctx.moveTo(cx - ARM_LEN/2, cy);
  ctx.lineTo(cx + ARM_LEN/2, cy);
  ctx.stroke();

  // vertical arm
  ctx.beginPath();
  ctx.moveTo(cx, cy - ARM_LEN/2);
  ctx.lineTo(cx, cy + ARM_LEN/2);
  ctx.stroke();
  ctx.restore();

  // Carve true inner fillets via destination-out quarter arcs
  const r = CHANNEL_W/2;
  const f = FILLET;
  ctx.save();
  ctx.globalCompositeOperation = 'destination-out';
  ctx.fillStyle = '#000';

  // TL corner
  let fx = cx - (r - f), fy = cy - (r - f);
  ctx.beginPath();
  ctx.moveTo(fx, fy);
  ctx.arc(fx, fy, f, 0, Math.PI/2, false);
  ctx.closePath();
  ctx.fill();

  // TR corner
  fx = cx + (r - f); fy = cy - (r - f);
  ctx.beginPath();
  ctx.moveTo(fx, fy);
  ctx.arc(fx, fy, f, Math.PI/2, Math.PI, false);
  ctx.closePath();
  ctx.fill();

  // BL corner
  fx = cx - (r - f); fy = cy + (r - f);
  ctx.beginPath();
  ctx.moveTo(fx, fy);
  ctx.arc(fx, fy, f, 1.5*Math.PI, 2*Math.PI, false);
  ctx.closePath();
  ctx.fill();

  // BR corner
  fx = cx + (r - f); fy = cy + (r - f);
  ctx.beginPath();
  ctx.moveTo(fx, fy);
  ctx.arc(fx, fy, f, Math.PI, 1.5*Math.PI, false);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawBall(ctx){
  ctx.save();
  ctx.fillStyle = '#e11d48';
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, BALL_R, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

// ========= p5 Sketch =========
function setup(){
  computeSize();
  recomputeDerived();
  const c = createCanvas(SIZE, SIZE);
  c.parent('wrap');
  pixelDensity(Math.min(2, window.devicePixelRatio || 1));
  pos = {x: cx, y: cy};
  initOverlay();
  window.addEventListener('resize', onResize);
  setupOrientationGuard();
}

function onResize(){
  const oldSize = SIZE;
  computeSize();
  recomputeDerived();
  resizeCanvas(SIZE, SIZE);
  const scale = SIZE/oldSize;
  pos.x *= scale; pos.y *= scale;
  updateOrientationGuard();
}

function draw(){
  const ctx = this.drawingContext;
  drawPlusFlat(ctx);

  let ax = 0, ay = 0;
  if (usingOrientation){ ax += acc.x; ay += acc.y; }
  ax += keyAccel.x * 0.6; ay += keyAccel.y * 0.6;

  vel.x += ax; vel.y += ay;
  vel.x *= FRICTION; vel.y *= FRICTION;

  let next = { x: pos.x + vel.x, y: pos.y + vel.y };
  const res = unionFilletedCrossClamp(next);
  pos = res.clamped;

  // Keep fully inside canvas
  pos.x = Math.max(BALL_R, Math.min(SIZE - BALL_R, pos.x));
  pos.y = Math.max(BALL_R, Math.min(SIZE - BALL_R, pos.y));

  drawBall(ctx);
  debugOut();
}

// ========= Device Orientation Handling =========
function handleOrientation(e){
  const g = e.gamma ?? 0; // left/right (-90..90)
  const b = e.beta ?? 0;  // front/back (-180..180)
  lastGamma = g; lastBeta = b;
  acc.x = GRAVITY * Math.sin(g * Math.PI/180);
  acc.y = GRAVITY * Math.sin(b * Math.PI/180);
}

async function askPermission(){
  try{
    let ok = true;
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
      const p1 = await DeviceOrientationEvent.requestPermission();
      ok = ok && (p1 === 'granted');
    }
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      const p2 = await DeviceMotionEvent.requestPermission();
      ok = ok && (p2 === 'granted');
    }
    if (ok){
      havePermission = true;
      startOrientation();
    }
  }catch(err){
    console.warn('Permission error', err);
  }finally{
    showHintAndFade();
  }
}

function startOrientation(){
  window.addEventListener('deviceorientation', handleOrientation, true);
  usingOrientation = true;
}

function initOverlay(){
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  const needsPerm = typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function';
  const btn = document.getElementById('ovBtn');
  btn.addEventListener('click', askPermission, {once:true});
  if (isIOS && needsPerm){
    setOverlayMode('permission');
  } else {
    startOrientation();
    setOverlayMode('hint');
    setTimeout(fadeOutOverlay, 900);
  }
}

// ========= Overlay control =========
function setOverlayMode(mode){
  const overlay = document.getElementById('overlay');
  const title = document.getElementById('ovTitle');
  const text  = document.getElementById('ovText');
  const btn   = document.getElementById('ovBtn');
  const hint  = document.getElementById('ovHint');
  overlay.classList.remove('hidden','fade-out');
  if (mode === 'permission'){
    title.textContent = 'Enable tilt controls';
    text.textContent  = 'On iPhone/iPad, Apple requires permission to read motion/orientation sensors.';
    btn.style.display = '';
    hint.textContent  = '(Desktop: use arrow keys to test)';
  } else {
    title.textContent = 'Tilt to roll';
    text.textContent  = '';
    btn.style.display = 'none';
    hint.textContent  = '';
  }
}

function showHintAndFade(){
  if (overlayDismissed) return;
  setOverlayMode('hint');
  setTimeout(fadeOutOverlay, 650);
}

function fadeOutOverlay(){
  if (overlayDismissed) return;
  const overlay = document.getElementById('overlay');
  overlay.classList.add('fade-out');
  overlay.addEventListener('transitionend', ()=>{
    overlay.classList.add('hidden');
    overlayDismissed = true;
  }, {once:true});
}

// ========= Keyboard fallback =========
const KEYS = {ArrowLeft:false, ArrowRight:false, ArrowUp:false, ArrowDown:false};
function updateKeyAccel(){
  keyAccel.x = (KEYS.ArrowRight?1:0) - (KEYS.ArrowLeft?1:0);
  keyAccel.y = (KEYS.ArrowDown?1:0) - (KEYS.ArrowUp?1:0);
}
window.addEventListener('keydown', (e)=>{ if (e.key in KEYS){ KEYS[e.key]=true; updateKeyAccel(); }});
window.addEventListener('keyup',   (e)=>{ if (e.key in KEYS){ KEYS[e.key]=false; updateKeyAccel(); }});

// ========= Portrait guard =========
let mql;
function setupOrientationGuard(){
  mql = window.matchMedia('(orientation: landscape)');
  mql.addEventListener('change', updateOrientationGuard);
  updateOrientationGuard();
}
function updateOrientationGuard(){
  const rot = document.getElementById('rotate');
  if (window.matchMedia('(orientation: landscape)').matches){
    rot.classList.add('show');
  } else {
    rot.classList.remove('show');
  }
}

// ========= Debug =========
function debugOut(){
  const el = document.getElementById('dbg');
  el.hidden = false;
  el.textContent = `size:${SIZE} ch:${CHANNEL_W} r:${BALL_R} fil:${FILLET}
perm:${havePermission} orient:${usingOrientation}
β:${lastBeta.toFixed(1)} γ:${lastGamma.toFixed(1)}
ax:${acc.x.toFixed(3)} ay:${acc.y.toFixed(3)}`;
}
</script>
</body>
</html>
