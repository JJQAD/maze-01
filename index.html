<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Maze Tilt Test · JJQAD</title>
  <!-- iOS web-app friendly bits -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Maze Tilt Test" />
  <style>
    :root{color-scheme:light dark}
    html,body{height:100%;margin:0}
    body{display:grid;place-items:center;background:#f5f5f7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #wrap{position:relative;width:800px;height:800px}
    canvas{display:block;border-radius:24px;box-shadow:0 10px 30px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.15)}
    /* overlay for permission / instructions */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:10}
    .card{backdrop-filter:blur(8px);background:rgba(255,255,255,.9);border:1px solid rgba(0,0,0,.08);border-radius:16px;padding:18px 20px;max-width:80%;text-align:center;box-shadow:0 6px 20px rgba(0,0,0,.12)}
    .btn{appearance:none;border:0;border-radius:12px;padding:12px 16px;font-weight:600;cursor:pointer}
    .btn-primary{background:#111;color:#fff}
    .muted{font-size:.9rem;opacity:.7;margin-top:8px}
    .debug{position:absolute;left:10px;top:10px;z-index:20;background:rgba(0,0,0,.55);color:#fff;padding:6px 8px;border-radius:8px;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:12px}
    @media (prefers-color-scheme:dark){
      body{background:#0f1114}
      .card{background:rgba(20,22,26,.8);color:#eaeef2;border-color:rgba(255,255,255,.1)}
      .btn-primary{background:#e11d48}
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <div id="wrap">
    <!-- p5 injects the canvas here -->
    <div id="permission" class="overlay" hidden>
      <div class="card">
        <div style="font-size:1.1rem;font-weight:700;margin-bottom:8px">Enable tilt controls</div>
        <div>On iPhone/iPad, Apple requires permission to read motion/orientation sensors.</div>
        <button class="btn btn-primary" id="askBtn" style="margin-top:12px">Enable Tilt</button>
        <div class="muted">(Desktop: use arrow keys to test)</div>
      </div>
    </div>
    <div id="info" class="overlay" style="pointer-events:none;" hidden>
      <div class="card" style="padding:10px 12px"><span id="hint">Tilt to roll</span></div>
    </div>
    <div id="dbg" class="debug" hidden>debug</div>
  </div>

<script>
// ========= Config =========
const SIZE = 800;             // canvas is 800 × 800 px
const CHANNEL_W = 140;        // visual width of carved channel
const BALL_R = 14;            // ball radius
const GRAVITY = 0.33;         // acceleration scale from tilt
const FRICTION = 0.992;       // surface friction (velocity damping)
const BOUNCE = 0.2;           // restitution when hitting channel walls

let cx = SIZE/2, cy = SIZE/2;
let pos = {x: cx, y: cy};
let vel = {x: 0, y: 0};
let acc = {x: 0, y: 0};

let usingOrientation = false;
let havePermission = false;
let keyAccel = {x:0, y:0};
let lastGamma = 0, lastBeta = 0;

// ========= Helpers =========
function clampToChannel(p){
  const half = CHANNEL_W/2;
  const dx = p.x - cx;
  const dy = p.y - cy;
  const insideH = Math.abs(dy) <= half; // within horizontal strip
  const insideV = Math.abs(dx) <= half; // within vertical strip

  if (insideH || insideV) return p; // allowed

  const penX = Math.abs(dx) - half;
  const penY = Math.abs(dy) - half;
  if (penX < penY){
    p.x = cx + Math.sign(dx) * half;
    vel.x *= -BOUNCE;
  } else {
    p.y = cy + Math.sign(dy) * half;
    vel.y *= -BOUNCE;
  }
  return p;
}

function drawChannel(g){
  const ctx = g.drawingContext;
  g.push();
  g.background('#ffffff');

  const vignette = ctx.createRadialGradient(cx, cy, SIZE*0.1, cx, cy, SIZE*0.8);
  vignette.addColorStop(0, 'rgba(0,0,0,0)');
  vignette.addColorStop(1, 'rgba(0,0,0,0.06)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0,0,SIZE,SIZE);

  function trench(x, y, w, h, isHorizontal){
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.clip();

    let grad;
    if (isHorizontal){
      grad = ctx.createLinearGradient(0, y, 0, y+h);
    } else {
      grad = ctx.createLinearGradient(x, 0, x+w, 0);
    }
    grad.addColorStop(0.00, 'rgba(0,0,0,0.16)');
    grad.addColorStop(0.06, 'rgba(0,0,0,0.08)');
    grad.addColorStop(0.50, 'rgba(0,0,0,0.18)');
    grad.addColorStop(0.94, 'rgba(0,0,0,0.08)');
    grad.addColorStop(1.00, 'rgba(0,0,0,0.16)');
    ctx.fillStyle = grad;
    ctx.fillRect(x, y, w, h);

    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = 'multiply';
    ctx.strokeStyle = 'rgba(0,0,0,0.07)';
    ctx.lineWidth = 2;
    ctx.strokeRect(x+1, y+1, w-2, h-2);
    ctx.restore();
  }

  const half = CHANNEL_W/2;
  trench(cx - half, 0, CHANNEL_W, SIZE, false);    // vertical
  trench(0, cy - half, SIZE, CHANNEL_W, true);     // horizontal

  g.pop();
}

function drawBall(g){
  g.push();
  g.noStroke();
  g.fill(0, 0, 0, 80);
  g.ellipse(pos.x, pos.y + BALL_R*0.65, BALL_R*2.2, BALL_R*0.9);
  const ctx = g.drawingContext;
  const grad = ctx.createRadialGradient(pos.x - BALL_R*0.4, pos.y - BALL_R*0.6, BALL_R*0.2, pos.x, pos.y, BALL_R);
  grad.addColorStop(0, '#ffb3b3');
  grad.addColorStop(0.35, '#ff4d4d');
  grad.addColorStop(1, '#b10818');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, BALL_R, 0, Math.PI*2);
  ctx.fill();
  g.fill(255, 255, 255, 180);
  g.ellipse(pos.x - BALL_R*0.45, pos.y - BALL_R*0.6, BALL_R*0.5);
  g.pop();
}

// ========= p5 Sketch =========
function setup(){
  const c = createCanvas(SIZE, SIZE);
  c.parent('wrap');
  pixelDensity(2);
  maybeShowPermissionOverlay();
  const hint = document.getElementById('hint');
  if (!isMobile()){ hint.textContent = 'Use arrow keys to roll'; }
}

function draw(){
  drawChannel(this);

  let ax = 0, ay = 0;
  if (usingOrientation){ ax += acc.x; ay += acc.y; }
  ax += keyAccel.x * 0.6; ay += keyAccel.y * 0.6;

  vel.x += ax; vel.y += ay;
  vel.x *= FRICTION; vel.y *= FRICTION;

  let next = { x: pos.x + vel.x, y: pos.y + vel.y };
  next = clampToChannel(next);
  next.x = Math.max(BALL_R, Math.min(SIZE - BALL_R, next.x));
  next.y = Math.max(BALL_R, Math.min(SIZE - BALL_R, next.y));
  pos = next;

  drawBall(this);

  debugOut();
}

// ========= Device Orientation Handling =========
function handleOrientation(e){
  const g = e.gamma ?? 0; // left/right (-90..90)
  const b = e.beta ?? 0;  // front/back (-180..180)
  lastGamma = g; lastBeta = b;
  acc.x = GRAVITY * Math.sin(g * Math.PI/180);
  acc.y = GRAVITY * Math.sin(b * Math.PI/180);
}

async function askPermission(){
  const overlay = document.getElementById('permission');
  try{
    let ok = true;
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
      const p1 = await DeviceOrientationEvent.requestPermission();
      ok = ok && (p1 === 'granted');
    }
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      const p2 = await DeviceMotionEvent.requestPermission();
      ok = ok && (p2 === 'granted');
    }
    if (ok){
      havePermission = true;
      startOrientation();
    }
  }catch(err){
    console.warn('Permission error', err);
  }finally{
    overlay.hidden = true;
    document.getElementById('info').hidden = false;
  }
}

function startOrientation(){
  window.addEventListener('deviceorientation', handleOrientation, true);
  usingOrientation = true;
}

function maybeShowPermissionOverlay(){
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  const needsPerm = typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function';
  const overlay = document.getElementById('permission');
  const info = document.getElementById('info');
  const btn = document.getElementById('askBtn');
  const trigger = ()=>askPermission();
  btn.addEventListener('click', trigger, {passive:true});
  btn.addEventListener('touchend', trigger, {passive:true});
  if (isIOS && needsPerm){
    overlay.hidden = false;
  } else {
    info.hidden = false;
    startOrientation();
  }
}

// ========= Keyboard fallback =========
const KEYS = {ArrowLeft:false, ArrowRight:false, ArrowUp:false, ArrowDown:false};
function updateKeyAccel(){
  keyAccel.x = (KEYS.ArrowRight?1:0) - (KEYS.ArrowLeft?1:0);
  keyAccel.y = (KEYS.ArrowDown?1:0) - (KEYS.ArrowUp?1:0);
}
window.addEventListener('keydown', (e)=>{ if (e.key in KEYS){ KEYS[e.key]=true; updateKeyAccel(); }});
window.addEventListener('keyup',   (e)=>{ if (e.key in KEYS){ KEYS[e.key]=false; updateKeyAccel(); }});

// ========= Utilities =========
function isMobile(){
  return /Android|iPhone|iPad|iPod|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

function debugOut(){
  const el = document.getElementById('dbg');
  el.hidden = false;
  el.textContent = `perm:${havePermission} orient:${usingOrientation}\nβ:${lastBeta.toFixed(1)} γ:${lastGamma.toFixed(1)}\nax:${acc.x.toFixed(3)} ay:${acc.y.toFixed(3)}`;
}
</script>
</body>
</html>
